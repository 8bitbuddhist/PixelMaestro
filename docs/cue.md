# Cue
A Cue is a PixelMaestro command that has been converted into a portable format. Cues are designed for controlling Maestros running on another device via serial communication. Cues can also be used to save configurations or [schedule commands](show.md) to run at a later time. Since Cues run on a Maestro, they can interact with anything the Maestro has access to.

## Contents
1. [Setting Up Cues](#setting-up-cues)
2. [Creating Cues](#creating-cues)
3. [Running Cues](#running-cues)
4. [Reading Cues](#reading-cues)
5. [Cue Components](#cue-components)
6. [Payload Components](#payload-components)

## Setting Up Cues
All Cue actions are controlled by a `CueController`, which processes and stores Cues for execution. Create a new CueController by calling `Maestro::add_cue_controller()`.

```c++
#include "core/maestro.h"
#include "cue/cuecontroller.h"

...
CueController* controller = maestro.add_cue_controller();
```

The Cues themselves are created by a `CueHandler`. CueHandlers contain methods for translate PixelMaestro commands into Cues as well as converting Cues back into PixelMaestro commands. Each of the core PixelMaestro classes has an associated CueHandler.

Since you may not need each and every CueHandler to be loaded into memory, you have to enable them individually using `CueController::enable_handler(CueController::Handler)`.

**Tip:** If a Cue was generated by a CueHandler (i.e. it resulted from a method call to that CueHandler), then the CueHandler must be activated for the Cue to be processed. Otherwise, the Cue will be ignored.

```c++
SectionCueHandler* handler = static_cast<SectionCueHandler*>(controller->enable_handler(CueController::Handler::SectionHandler));

// Create a Cue that adds a new Canvas. The Cue is saved to the CueController.
handler->add_canvas(0, 1, CanvasType::AnimationCanvas);
```

## Creating Cues
You can create a Cue by calling one of the methods in an enabled CueHandler class. For example, to create a Cue that changes a Section's dimensions, enable a SectionCueHandler and call `handler.set_dimensions(section, overlay, x, y)`, where `section` and `overlay` are the indices of the Section and Overlay you want to modify (leave the Overlay index as 0 if you just want to modify the Section). This generates a Cue and stores it in the CueController's buffer, which you can access using `CueController::get_cue()`.

**Note:** Most methods require you to pass in the ID of the Section you want to modify.

The following example demonstrates using two Cues to create a Canvas and draw a circle on an Overlay:
```c++
#include "cue/cuecontroller.h"
#include "cue/canvascuehandler.h"
#include "cue/sectioncuehandler.h"

...
// The index of the Section (in `Maestro::sections_`).
// This is required for almost all Cues.
int section_index = 0;

// If modifying an Overlay, this indicates how far down the Overlay is.
// For example, an index of 1 affects the Section's Overlay, while an index of 2 affects the Overlay's Overlay.
int overlay_index = 1;

section_handler->add_canvas(section_index, overlay_index, CanvasType::ColorCanvas);
controller->run();

canvas_handler->draw_circle(section_index, overlay_index, Colors::GREEN, 5, 5, 2, true);
controller->run();
```

## Running Cues
After calling a Handler method, you can immediately run the generated Cue by using `CueController::run()`.

**Note:** Don't call a Handler's `run` method directly, as this will bypass error checking and validation.

### Running External Cues
In addition to running cached Cues, you can run unloaded Cues by using `CueController::run(unsigned char* cue)` and passing the Cue as the parameter. This lets you pass in Cues from an external source, such as file. You can run multiple Cues sequentially using `CueController::run(unsigned char* cues, unsigned char num_cues)`. The first method loads in a single Cue, while the second loads an array of Cues and runs each Cue sequentially.

For cases where you want to feed in a Cue byte-by-byte (e.g. using `Serial.read()` on an Arduino), use `CueController::read(byte)`. Each byte is loaded into the CueController's buffer until the Cue has loaded completely, then the Cue is automatically executed. The buffer then resets and repeats the process for the next incoming Cue.

```c++
// Setup
Serial.begin(9600);

// Loop
if (Serial.available()) {
	controller.read(Serial.read());
}
```

**The following sections are for reference/curiosity only.**

## Cue Components
At its core, a Cue is just a string of bytes approximately 20 characters long. Cues contain the following parts:

1. **ID**: a simple string used to identify the start of a PixelMaestro Cue.
2. **Size**: the size of the PixelMaestro command (aka the _payload_).
3. **Checksum**: a value calculated to confirm the integrity of the data received. This is done by summing up the entire command, dividing by 256, and taking the remainder.
4. **Payload**: the actual serialized PixelMaestro command.

The ID and checksum are used as validation when loading a Cue from external sources. Cues generated from within the CueController bypass these steps.

## Payload Components
Payloads can vary in length depending on the command (hence the _size_ component), but all payloads contain all of these components (excluding Type in some cases):

1. **Handler**: the CueHandler that generated this Cue. This helps the CueController delegate incoming Cues to different Handlers.
2. **Action**: the Handler-specific method that created this Cue. This is where CueHandler methods map to PixelMaestro methods.
3. **Type**: identifies one of several possible options in the command, e.g. a canvas type or font name.
4. **Section**: the index of the Section that this Cue modifies.
4. **Overlay**: the index of the affected Overlay in relation to the Section.
5. **Options**: A variable-length set of parameters custom to each Action.

[Home](README.md)
