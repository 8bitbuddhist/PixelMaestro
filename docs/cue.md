# Cue
A Cue is a PixelMaestro command that has been converted into a portable format. Cues are designed for controlling Maestros running on another device via serial communication. Cues can also be used to save configurations or [schedule commands](show.md) to run at a later time. Since Cues run on a Maestro, they can interact with anything the Maestro has access to.

## Contents
1. [Setting Up Cues](#setting-up-cues)
2. [Creating Cues](#creating-cues)
3. [Running Cues](#running-cues)
4. [Reading Cues](#reading-cues)
5. [Cue Parameters](#cue-parameters)
6. [Payload Parameters](#payload-parameters)

## Setting Up Cues
All Cue actions are controlled by a `CueController`, which processes and stores Cues for execution. Create a new CueController by calling `Maestro::set_cue_controller()`. Calling [`Maesto::set_show()`](show.md) also creates a new CueController.

```c++
#include "core/maestro.h"
#include "cue/cuecontroller.h"
...
CueController* controller = maestro.set_cue_controller();
```

The Cues themselves are created by a `CueHandler`. CueHandlers contain methods for generating Cues from PixelMaestro commands, as well as running PixelMaestro commands from Cues. Each of the main PixelMaestro classes has an associated CueHandler.

You can enable a CueHandler using `CueController::enable_handler(CueController::Handler)`. Since CueHandlers use a relatively large amount of memory, you should only enable the CueHandlers you need.

**Tip:** If a Cue was generated by a CueHandler (i.e. it resulted from a method call to that CueHandler), then the CueHandler must be enabled for the Cue to be processed. Otherwise, the Cue will be ignored.

```c++
SectionCueHandler* handler = static_cast<SectionCueHandler*>(controller->enable_handler(CueController::Handler::SectionHandler));
```

## Creating Cues
You can create a Cue by calling one of the methods in an enabled CueHandler class. For example, to create a Cue that changes a Section's dimensions, enable a `SectionCueHandler` and call `handler.set_dimensions(section, overlay, x, y)`, where `section` and `overlay` are the indices of the Section and Overlay you want to modify (leave the Overlay index as 0 if you just want to modify the Section). This generates a Cue and stores it in the CueController's buffer, which you can access using `CueController::get_cue()`.

**Note:** All Handler methods require you to pass in the index of the Section and Overlay you want to modify. The Overay index indicates the number of Overlays from the base Section (index 0 points to the base Section itself).

The following example demonstrates using two Cues to create a Canvas and draw a circle on an Overlay:
```c++
#include "cue/cuecontroller.h"
#include "cue/canvascuehandler.h"
#include "cue/sectioncuehandler.h"

...
// The index of the Section (in `Maestro::sections_`).
int section_index = 02

// This indicates how far down the Overlay is.
// For example, an index of 1 affects the base Section's Overlay, while an index of 2 affects the Overlay's Overlay.
int overlay_index = 1;

SectionCueHandler* section_handler = static_cast<SectionCueHandler*>(controller->enable_handler(CueController::Handler::SectionHandler));
section_handler->add_canvas(section_index, overlay_index, CanvasType::ColorCanvas);
controller->run();

CanvasCueHandler* canvas_handler = static_cast<CanvasCueHandler*>(controller->enable_handler(CueController::Handler::CanvasHandler));
canvas_handler->draw_circle(section_index, overlay_index, Colors::GREEN, 5, 5, 2, true);
controller->run();
```

## Running Cues
After calling a CueHandler method, you can immediately run the generated Cue by using `CueController::run()`.

**Note:** Don't call a Handler's `run` method directly, as this will bypass error checking and validation.

### Running External Cues
You can also run Cues by using `CueController::run(unsigned char* cue)` and passing the Cue as the parameter. This lets you pass in Cues from an external source such as a file or serial device. You can also run a multiple Cues sequentially using `CueController::run(unsigned char* cues, unsigned char num_cues)`.

For cases where you can only read parts of a Cue at a time (e.g. using `Serial.read()` on an Arduino), use `CueController::read(byte)`. Each byte is loaded into the CueController's buffer until the Cue has loaded completely, then the Cue is automatically executed. The buffer then resets and repeats the process for the next incoming Cue.

```c++
// Setup
Serial.begin(9600);

// Loop
if (Serial.available()) {
	controller.read(Serial.read());
}
```

**The following sections are for reference/curiosity only.**

## Cue Parameters
At its core, a Cue is just a string of bytes approximately 20 characters long. Cues contain the following parts:

1. **ID**: a simple string used to identify the start of a PixelMaestro Cue.
2. **Size**: the size of the PixelMaestro command (aka the _payload_).
3. **Checksum**: a value calculated to confirm the integrity of the data received. This is done by summing up the entire command, dividing by 256, and taking the remainder.
4. **Payload**: the contents of the PixelMaestro command.

The ID and checksum are used as validation when loading Cues from external sources, whereas Cues generated from within the CueController bypass this step altogether.

## Payload Parameters
Payloads can vary in length depending on the command (hence the _size_ component), but each payload contains almost all of these parameters:

1. **Handler**: the CueHandler that generated this Cue. This helps the CueController delegate incoming Cues to different CueHandlers.
2. **Action**: the CueHandler-specific method that created this Cue. This is also used to map CueHandler methods to PixelMaestro methods.
3. **Type**: identifies one of several possible options, e.g. a canvas type or animation type. Only a few CueHandlers use this parameter.
4. **Section**: the index of the Section that this Cue modifies.
4. **Overlay**: the index of the Overlay that this Cue modifies in relation to the Section.
5. **Options**: A variable-length set of options custom to each Action.

[Home](README.md)
