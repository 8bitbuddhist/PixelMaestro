# Cue
A Cue is a serialized PixelMaestro commands. Using Cues, you can recreate a Maestro by loading a file, send commands to other devices, or [schedule commands](show.md) to run at a later time.

**Warning:** Cues are RAM-hungry. You may run into issues on low-memory devices such as an Arduino Uno.

## Contents
1. [Enabling Cues](#enabling-cues)
2. [Creating Cues](#creating-cues)
3. [Running Cues](#running-cues)
4. [Header Parameters](#header-parameters)
5. [Payload Parameters](#payload-parameters)

## Enabling Cues
All Cues pass through a `CueController`. CueControllers are responsible for assembling outgoing Cues and processing incoming Cues. Create a new CueController by calling `Maestro::set_cue_controller()`. Calling [`Maesto::set_show()`](show.md) also creates a new CueController.

```c++
#include "core/maestro.h"
#include "cue/cuecontroller.h"
...
CueController* controller = maestro.set_cue_controller();
```

Cues are generated by a `CueHandler`, which map Cues to and from PixelMaestro commands. Each of the core PixelMaestro classes has an associated CueHandler.

Before using a CueHandler, you have to enable it using `CueController::enable_handler(CueController::Handler)`. This returns a pointer to the new CueHandler. Enabling a CueHandler lets you generate and interpret Cues using that CueHandler. Each CueHandler is relatively large, so you should only enable specific CueHandlers on smaller devices.

```c++
SectionCueHandler* handler = static_cast<SectionCueHandler*>(controller->enable_handler(CueController::Handler::SectionHandler));
```

## Creating Cues
You can create a Cue by calling one of the methods in an enabled CueHandler. For example, to create a Cue that changes a Section's dimensions, enable the `SectionCueHandler` and call `handler.set_dimensions(section, overlay, x, y)`, where `section` and `overlay` are the indices of the Section and Overlay you want to modify (leave the Overlay index as 0 if you just want to modify the base Section). This generates and returns a pointer to the new Cue. This also stores the Cue in the CueController's buffer, which you can access using `CueController::get_cue()`.

**Note:** All Handler methods require you to pass in the index of the Section and Overlay you want to modify. The Overay index indicates the depth of the Overlay from the base Section (index 0 points to the base Section itself).

The following example demonstrates creating a Canvas on an Overlay and drawing a circle on the Canvas:
```c++
#include "cue/cuecontroller.h"
#include "cue/canvascuehandler.h"
#include "cue/sectioncuehandler.h"

...
// The index of the Section (in `Maestro::sections_`).
int section_index = 0;

// How far down the Overlay is.
// For example, an index of 1 affects the base Section's Overlay, while an index of 2 affects the Overlay's Overlay.
int overlay_index = 1;

SectionCueHandler* section_handler = static_cast<SectionCueHandler*>(controller->enable_handler(CueController::Handler::SectionHandler));
// Single-step approach
controller->run(section_handler->add_canvas(section_index, overlay_index, CanvasType::ColorCanvas));

CanvasCueHandler* canvas_handler = static_cast<CanvasCueHandler*>(controller->enable_handler(CueController::Handler::CanvasHandler));
// Two-step approach
canvas_handler->draw_circle(section_index, overlay_index, Colors::GREEN, 5, 5, 2, true);
controller->run();
```

## Running Cues
After calling a CueHandler method, you can immediately run the Cue using `CueController::run()`. You can also run a Cue using `CueController::run(unsigned char* cue)` and passing the Cue as the parameter. This lets you pass in Cues from external sources such as files. You can also run multiple Cues sequentially using `CueController::run(unsigned char* cues, unsigned char num_cues)`.

For cases where you need to read in parts of a Cue at a time (e.g. using `Serial.read()` on an Arduino), use `CueController::read(byte)`. This reads each byte into the CueController's buffer until the Cue has loaded completely, then automatically executes the Cue. The buffer then resets and repeats the process for the next incoming Cue.

```c++
// Setup
Serial.begin(9600);

// Loop
if (Serial.available()) {
	controller.read(Serial.read());
}
```

**The following sections are for reference/curiosity only.**

## Header Parameters
Cues are byte arrays approximately 20 elements long. Each Cue starts with a header, which contains the following parts:

1. **ID**: a simple string used to identify the start of a Cue.
2. **Size**: the size of the command (aka the _payload_).
3. **Checksum**: a generated value confirming the integrity of the Cue. This is done by summing up the entire Cue, dividing by 256, and taking the remainder.

The ID and checksum are used as validation when loading Cues from external sources, whereas Cues generated from within the CueController bypass this step altogether.

After the Checksum is the _payload_, which contains the actual command.

## Payload Parameters
Payloads vary in length depending on the command (stored in the _size_ component of the header), but each payload contains almost all of these parameters:

1. **Handler**: the CueHandler that generated this Cue. This lets the CueController delegate incoming Cues to the appropriate CueHandler.
2. **Action**: the CueHandler-specific method that created this Cue. CueHandlers use this to determine which PixelMaestro command to run using this Cue.
3. **Type**: identifies one of several possible options, e.g. a Canvas type or Animation type. Only certain CueHandlers use this parameter.
4. **Section**: the index of the Section that this Cue modifies.
4. **Overlay**: the index of the Overlay that this Cue modifies in relation to the Section (e.g. a value of *2* affects the Section's Overlay's Overlay).
5. **Options**: A variable-length set of options specific to each Action. Most Options are less than 10 bytes long, but some (e.g. setting color arrays or copying Canvas frames) can easily reach 1KB+.

[Home](README.md)
